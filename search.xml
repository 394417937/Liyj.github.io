<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实现深浅拷贝</title>
      <link href="/2022/09/22/article-4/"/>
      <url>/2022/09/22/article-4/</url>
      
        <content type="html"><![CDATA[<h1 id="实现一个深浅拷贝"><a href="#实现一个深浅拷贝" class="headerlink" title="实现一个深浅拷贝"></a>实现一个深浅拷贝</h1><ul><li><p>浅拷贝: 拷贝对象的一层属性,如果对象里面还有对象,拷贝的是地址, 两者之间修改会有影响,适用于对象里面属性的值是简单数据类型的</p></li><li><p>深拷贝: 拷贝对象的多层属性,如果对象里面还有对象,会继续拷贝,使用递归去实现.</p></li></ul><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ol><li><p>for循环第一层</p><pre class="line-numbers language-none"><code class="language-none">var obj &#x3D; &#123;    class: &#39;UI&#39;,    age: 20,    love: &#39;eat&#39;    &#125;    function getObj(obj) &#123;      var newObj &#x3D; &#123;&#125;      for (var k in obj) &#123;        newObj[k] &#x3D; obj[k]      &#125;      return newObj    &#125;    var obj2 &#x3D; getObj(obj)    console.log(obj2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Object.assign()<br> Object.assign我们经常会用到合并对象</p><pre class="line-numbers language-none"><code class="language-none">var obj1 &#x3D; &#123;a: 1, b: 2&#125;&#x2F;&#x2F; Object.assign的第一个参数一定要是一个空对象var obj2 &#x3D; Object.assign(&#123;&#125;, obj1)obj2.a &#x3D; 4console.log(obj1, obj2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>…扩展运算符</p><pre class="line-numbers language-none"><code class="language-none">var obj1 &#x3D; &#123;a: 1, b: 2&#125;var obj2 &#x3D; &#123;...obj1&#125; obj2.a &#x3D; 4console.log(obj1, obj2)&#x2F;&#x2F; 打印obj1 -&gt; a:1, b:2&#x2F;&#x2F; 打印obj2 -&gt; a:4, b:2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Array.concat()</p><pre class="line-numbers language-none"><code class="language-none">const oldArr &#x3D; [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;,&#123;name:&quot;Four&quot;&#125;]const newArr &#x3D; oldArr.concat([&quot;Six&quot;])newArr[1] &#x3D; &quot;love&quot;;newArr[3].name &#x3D; &#39;Five&#39;console.log(oldArr) &#x2F;&#x2F;  [&#39;One&#39;, &#39;Two&#39;, &#39;Three&#39;, &#123; name: &#39;Five&#39; &#125; ]console.log(newArr) &#x2F;&#x2F; [ &#39;One&#39;, &#39;love&#39;, &#39;Three&#39;, &#123; name: &#39;Five&#39; &#125;, &#39;Six&#39;  ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Array.slice()</p><pre class="line-numbers language-none"><code class="language-none">const oldArr &#x3D; [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;,&#123;name:&quot;Four&quot;&#125;]const newArr &#x3D; oldArr.slice(0)newArr[1] &#x3D; &quot;love&quot;;newArr[3].name &#x3D; &#39;Five&#39;console.log(oldArr) &#x2F;&#x2F;  [&#39;One&#39;, &#39;Two&#39;, &#39;Three&#39;, &#123; name: &#39;Five&#39; &#125; ]console.log(newArr) &#x2F;&#x2F; [ &#39;One&#39;, &#39;love&#39;, &#39;Three&#39;, &#123; name: &#39;Five&#39; &#125; ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ol><li>JSON.stringify<br> 不能处理函数和正则，而且当对象中有循环引用会报错</li></ol><pre class="line-numbers language-none"><code class="language-none">const oldObj &#x3D; &#123;    name: &#39;李扬洁&#39;,    name1: &#123;value:3&#125;&#125;const newObj &#x3D; JSON.parse(JSON.stringify(oldObj));newObj.name &#x3D; &#39;小菜鸡&#39;newObj.name1.value &#x3D; 4console.log(oldObj) &#x2F;&#x2F; &#123;name: &#39;李扬洁&#39;,name1: &#123; value: 3 &#125;&#125;console.log(newObj) &#x2F;&#x2F; &#123; name: &#39;小菜鸡&#39;, name1: &#123; value: 4 &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>_.cloneDeep() 深度克隆</p><pre class="line-numbers language-none"><code class="language-none">const _ &#x3D; require(&#39;lodash&#39;);let oldObj &#x3D; &#123;    a: 1, b: 2,c:&#123;value:3&#125;&#125;let newObj &#x3D; _.cloneDeep(oldObj)newObj.a &#x3D; 2newObj.c.value &#x3D; 4console.log(oldObj) &#x2F;&#x2F; &#123; a: 1, b: 2, c: &#123; value: 3 &#125; &#125;console.log(newObj) &#x2F;&#x2F; &#123; a: 2, b: 2, c: &#123; value: 4 &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>递归</p><pre class="line-numbers language-none"><code class="language-none">function deepClone(obj, hash &#x3D; new WeakMap()) &#123;    if (obj &#x3D;&#x3D;&#x3D; null) return obj; &#x2F;&#x2F; 如果是null或者undefined我就不进行拷贝操作    if (obj instanceof Date) return new Date(obj);    if (obj instanceof RegExp) return new RegExp(obj);    &#x2F;&#x2F; 可能是对象或者普通的值  如果是函数的话是不需要深拷贝    if (typeof obj !&#x3D;&#x3D; &quot;object&quot;) return obj;    &#x2F;&#x2F; 是对象的话就要进行深拷贝    if (hash.get(obj)) return hash.get(obj);    let cloneObj &#x3D; new obj.constructor();    &#x2F;&#x2F; 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身    hash.set(obj, cloneObj);    for (let key in obj) &#123;      if (obj.hasOwnProperty(key)) &#123;        &#x2F;&#x2F; 实现一个递归拷贝        cloneObj[key] &#x3D; deepClone(obj[key], hash);      &#125;    &#125;    return cloneObj;&#125;const obj1 &#x3D; &#123;    a: 1,    b: [1, 2],&#125;obj1.c &#x3D; obj1const obj2 &#x3D; deepClone(obj1)obj2.a &#x3D; 2obj2.b.push(3)console.log(obj1)console.log(obj2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>px/em/rem的区别与rem的原理</title>
      <link href="/2022/09/22/article-3/"/>
      <url>/2022/09/22/article-3/</url>
      
        <content type="html"><![CDATA[<h1 id="px-x2F-em-x2F-rem的区别与rem的原理"><a href="#px-x2F-em-x2F-rem的区别与rem的原理" class="headerlink" title="px&#x2F;em&#x2F;rem的区别与rem的原理"></a>px&#x2F;em&#x2F;rem的区别与rem的原理</h1><h2 id="px-x2F-em-x2F-rem的区别"><a href="#px-x2F-em-x2F-rem的区别" class="headerlink" title="px&#x2F;em&#x2F;rem的区别"></a>px&#x2F;em&#x2F;rem的区别</h2><ol><li>px 是固定的像素，一旦设置了就无法因为适应页面大小而改变</li><li>em 和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局</li><li>em 相对自身font-size，没有则相对于父元素，rem相对于根元素的font-size</li></ol><h2 id="rem的原理"><a href="#rem的原理" class="headerlink" title="rem的原理"></a>rem的原理</h2><ol><li>rem 是css的相对单位，rem缩放是相对根元素字体大小.</li><li>rem 布局的本质是等比缩放，一般是基于宽度。</li><li>rem 会配合媒体查询（或js动态获取屏幕宽度）来一起使用，来实现屏幕的适配。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css3新特性</title>
      <link href="/2022/09/22/article-2/"/>
      <url>/2022/09/22/article-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Css3新特性"><a href="#Css3新特性" class="headerlink" title="Css3新特性"></a>Css3新特性</h1><ol><li>圆角 border-radius</li><li>盒子模型 box-sizing</li><li>阴影 box-shadow 盒子阴影  text-shadow 文字阴影</li><li>过渡 transition</li><li>2D转换transform  translate(平移) scale(缩放)  skew(斜切) rotate(旋转) transform-origin 控制转换中心点</li><li>3D转换 perspective(透视距)  transform-style(3D控件效果)</li><li>渐变 linear-gradient radial-gradient</li><li>弹性布局 flex</li><li>媒体查询 @media screen and () {…}</li><li>边框图片 border-image</li><li>自定义动画 @keyframes    animation</li><li>颜色 新增RGBA HSLA模式</li><li>背景 background-size   background-origin   background-clip</li></ol>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex的基本使用</title>
      <link href="/2022/09/22/article-1/"/>
      <url>/2022/09/22/article-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Flex的基本使用"><a href="#Flex的基本使用" class="headerlink" title="Flex的基本使用"></a>Flex的基本使用</h1><ol><li><p>弹性盒子组成<br> &#x2F;* 弹性容器 <em>&#x2F;<br> display:flex;<br> &#x2F;</em> 主轴 <em>&#x2F;<br> justify-content<br> &#x2F;</em> 侧轴*&#x2F;<br> align-items</p></li><li><p>主轴对齐方式<br> &#x2F;* 默认值 左上角开始 *&#x2F;<br> justify-content: flex-start; </p><p> &#x2F;* 右上角开始 *&#x2F;<br> justify-content: flex-end;</p><p> &#x2F;* 水平居中对齐 重要*&#x2F;<br> justify-content: center; </p><p> &#x2F;* 间距在子盒子的两侧 *&#x2F;<br> justify-content: space-around; </p><p> &#x2F;* 两端对齐 空间在子盒子之间 重要*&#x2F;<br> justify-content: space-between; </p><p> &#x2F;* 盒子的所有间距都相等 *&#x2F;<br> justify-content: space-evenly;</p></li><li><p>侧轴对齐方式<br>&#x2F;* 顶部对齐 *&#x2F;<br>align-items: flex-start; </p><p>&#x2F;* 底部对齐 *&#x2F;<br>align-items: flex-end; </p><p>&#x2F;* 垂直居中对齐 重点*&#x2F;<br>align-items: center; </p><p>&#x2F;*默认值 顶部对齐 当子盒子没有高度时  会将子盒子拉伸充满整个容器 *&#x2F;<br>align-items: stretch;</p></li><li><p>改变主轴方向<br> &#x2F;* 改变主轴方向  默认是水平 从左到右排列  *&#x2F;<br> flex-direction: row; </p><p> &#x2F;* 垂直方向 从上向下  重点*&#x2F;<br> flex-direction: column;</p><p> &#x2F;* 水平排列  从右向左 *&#x2F;<br> flex-direction: row-reverse; </p><p> &#x2F;* 垂直方向  从下向上 *&#x2F;<br> flex-direction: column-reverse;</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
